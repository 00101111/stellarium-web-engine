// Auto generated from tools/makeassets.py

static const unsigned char DATA_data_shaders_blit_frag[359] __attribute__((aligned(4))) =
    "#ifdef GL_ES\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "uniform sampler2D u_tex;\n"
    "uniform float u_stripes;\n"
    "\n"
    "varying vec2 v_tex_pos;\n"
    "varying vec4 v_color;\n"
    "\n"
    "void main()\n"
    "{\n"
    "    gl_FragColor = texture2D(u_tex, v_tex_pos) * v_color;\n"
    "\n"
    "    if (u_stripes != 0.0) {\n"
    "        float k = v_tex_pos.x;\n"
    "        k = step(0.5, fract(k * u_stripes));\n"
    "        gl_FragColor.a *= k;\n"
    "    }\n"
    "}\n"
    "";

ASSET_REGISTER(data_shaders_blit_frag, "shaders/blit.frag", DATA_data_shaders_blit_frag, false)

static const unsigned char DATA_data_shaders_blit_vert[256] __attribute__((aligned(4))) =
    "attribute vec4 a_pos;\n"
    "attribute vec2 a_tex_pos;\n"
    "attribute vec3 a_color;\n"
    "\n"
    "uniform vec4 u_color;\n"
    "\n"
    "varying vec2 v_tex_pos;\n"
    "varying vec4 v_color;\n"
    "\n"
    "void main()\n"
    "{\n"
    "    gl_Position = a_pos;\n"
    "    v_tex_pos = a_tex_pos;\n"
    "    v_color = vec4(a_color, 1.0) * u_color;\n"
    "}\n"
    "";

ASSET_REGISTER(data_shaders_blit_vert, "shaders/blit.vert", DATA_data_shaders_blit_vert, false)

static const unsigned char DATA_data_shaders_blit_tag_frag[217] __attribute__((aligned(4))) =
    "#ifdef GL_ES\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "uniform sampler2D u_tex;\n"
    "\n"
    "varying vec2 v_tex_pos;\n"
    "varying vec4 v_color;\n"
    "\n"
    "void main()\n"
    "{\n"
    "    gl_FragColor = v_color;\n"
    "    gl_FragColor.a *= texture2D(u_tex, v_tex_pos).r;\n"
    "}\n"
    "";

ASSET_REGISTER(data_shaders_blit_tag_frag, "shaders/blit_tag.frag", DATA_data_shaders_blit_tag_frag, false)

static const unsigned char DATA_data_shaders_blit_tag_vert[256] __attribute__((aligned(4))) =
    "attribute vec4 a_pos;\n"
    "attribute vec2 a_tex_pos;\n"
    "attribute vec3 a_color;\n"
    "\n"
    "uniform vec4 u_color;\n"
    "\n"
    "varying vec2 v_tex_pos;\n"
    "varying vec4 v_color;\n"
    "\n"
    "void main()\n"
    "{\n"
    "    gl_Position = a_pos;\n"
    "    v_tex_pos = a_tex_pos;\n"
    "    v_color = vec4(a_color, 1.0) * u_color;\n"
    "}\n"
    "";

ASSET_REGISTER(data_shaders_blit_tag_vert, "shaders/blit_tag.vert", DATA_data_shaders_blit_tag_vert, false)

static const unsigned char DATA_data_shaders_planet_frag[2091] __attribute__((aligned(4))) =
    "#ifdef GL_ES\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "#define PI 3.14159265\n"
    "\n"
    "uniform sampler2D u_tex;\n"
    "uniform sampler2D u_normal_tex;\n"
    "uniform vec3 u_light_dir;\n"
    "uniform vec3 u_light_emit;\n"
    "uniform mat4 u_mv;\n"
    "uniform int u_has_normal_tex;\n"
    "\n"
    "varying vec3 v_pos;\n"
    "varying vec2 v_tex_pos;\n"
    "varying vec4 v_color;\n"
    "varying vec3 v_normal;\n"
    "varying vec3 v_tangent;\n"
    "varying vec3 v_bitangent;\n"
    "\n"
    "float oren_nayar_diffuse(\n"
    "        vec3 lightDirection,\n"
    "        vec3 viewDirection,\n"
    "        vec3 surfaceNormal,\n"
    "        float roughness,\n"
    "        float albedo) {\n"
    "\n"
    "    float r2 = roughness * roughness;\n"
    "    float LdotV = dot(lightDirection, viewDirection);\n"
    "    float NdotL = dot(lightDirection, surfaceNormal);\n"
    "    float NdotV = dot(surfaceNormal, viewDirection);\n"
    "    float NaL = acos(NdotL);\n"
    "    float NaV = acos(NdotV);\n"
    "    float alpha = max(NaV, NaL);\n"
    "    float beta = min(NaV, NaL);\n"
    "    float gamma = dot(viewDirection - surfaceNormal * NdotV,\n"
    "                      lightDirection - surfaceNormal * NdotL);\n"
    "    float A = 1.0 - 0.5 * (r2 / (r2 + 0.33));\n"
    "    float B = 0.45 * r2 / (r2 + 0.09);\n"
    "    float C = sin(alpha) * tan(beta);\n"
    "    float scale = 1.6; // Empirical value!\n"
    "    return max(0.0, NdotL) * (A + B * max(0.0, gamma) * C) * scale;\n"
    "}\n"
    "\n"
    "void main()\n"
    "{\n"
    "    // Compute N in view space\n"
    "    vec3 n = v_normal;\n"
    "    if (u_has_normal_tex != 0) {\n"
    "        n = texture2D(u_normal_tex, v_tex_pos).rgb - vec3(0.5, 0.5, 0.0);\n"
    "        n.z *= 0.2; // XXX: amplify the normal map!\n"
    "        // XXX: inverse the Y coordinates, don't know why!\n"
    "        n = normalize(+n.x * v_tangent - n.y * v_bitangent + n.z * v_normal);\n"
    "    }\n"
    "    n = normalize((u_mv * vec4(n, 0.0)).xyz);\n"
    "    gl_FragColor = texture2D(u_tex, v_tex_pos) * v_color;\n"
    "#ifndef NO_OREN_NAYAR\n"
    "    float power = oren_nayar_diffuse(u_light_dir,\n"
    "                                     normalize(-v_pos),\n"
    "                                     n,\n"
    "                                     0.9, 0.12);\n"
    "    gl_FragColor.rgb *= power;\n"
    "#else\n"
    "    vec3 light = vec3(0.0, 0.0, 0.0);\n"
    "    light += max(0.0, dot(n, u_light_dir));\n"
    "    light += u_light_emit;\n"
    "    gl_FragColor.rgb *= light;\n"
    "#endif\n"
    "}\n"
    "";

ASSET_REGISTER(data_shaders_planet_frag, "shaders/planet.frag", DATA_data_shaders_planet_frag, false)

static const unsigned char DATA_data_shaders_planet_vert[718] __attribute__((aligned(4))) =
    "attribute vec4 a_pos;\n"
    "attribute vec4 a_vpos;\n"
    "attribute vec2 a_tex_pos;\n"
    "attribute vec3 a_color;\n"
    "attribute vec3 a_normal;\n"
    "attribute vec3 a_tangent;\n"
    "\n"
    "uniform vec4 u_color;\n"
    "\n"
    "varying vec3 v_pos;\n"
    "varying vec2 v_tex_pos;\n"
    "varying vec4 v_color;\n"
    "varying vec3 v_normal;\n"
    "varying vec3 v_tangent;\n"
    "varying vec3 v_bitangent;\n"
    "\n"
    "void main()\n"
    "{\n"
    "    gl_Position = a_pos;\n"
    "    v_pos = a_vpos.xyz;\n"
    "    v_tex_pos = a_tex_pos;\n"
    "    v_color = vec4(a_color, 1.0) * u_color;\n"
    "\n"
    "    // XXX: for the moment we use spherical coordinates tangent,\n"
    "    // like in stellarium.\n"
    "    v_normal = a_normal;\n"
    "    v_tangent = normalize(cross(vec3(0.0, 0.0, 1.0), v_normal));\n"
    "    // v_tangent = a_tangent;\n"
    "    v_bitangent = normalize(cross(v_normal, v_tangent));\n"
    "\n"
    "}\n"
    "";

ASSET_REGISTER(data_shaders_planet_vert, "shaders/planet.vert", DATA_data_shaders_planet_vert, false)

static const unsigned char DATA_data_shaders_points_frag[450] __attribute__((aligned(4))) =
    "#ifdef GL_ES\n"
    "precision mediump float;\n"
    "#endif\n"
    "\n"
    "uniform float u_smooth;\n"
    "\n"
    "varying vec2 v_tex_pos;\n"
    "varying vec4 v_color;\n"
    "\n"
    "float dist;\n"
    "float k;\n"
    "\n"
    "void main()\n"
    "{\n"
    "    dist = 2.0 * distance(v_tex_pos, vec2(0.5, 0.5));\n"
    "    k = smoothstep(1.0 - u_smooth, 1.0, dist);\n"
    "    k = sqrt(k);\n"
    "    gl_FragColor.rgb = v_color.rgb;\n"
    "    // Saturation effect at the center.\n"
    "    gl_FragColor.rgb *= 1.0 + smoothstep(0.2, 0.0, k);\n"
    "    gl_FragColor.a = v_color.a * (1.0 - k);\n"
    "}\n"
    "";

ASSET_REGISTER(data_shaders_points_frag, "shaders/points.frag", DATA_data_shaders_points_frag, false)

static const unsigned char DATA_data_shaders_points_vert[318] __attribute__((aligned(4))) =
    "attribute vec4 a_pos;\n"
    "attribute vec2 a_tex_pos;\n"
    "attribute vec4 a_color;\n"
    "attribute vec2 a_shift;\n"
    "\n"
    "varying vec2 v_tex_pos;\n"
    "varying vec4 v_color;\n"
    "\n"
    "uniform vec4 u_color;\n"
    "\n"
    "void main()\n"
    "{\n"
    "    vec4 pos = a_pos;\n"
    "    pos.xy += 2.0 * a_shift;\n"
    "    gl_Position = pos;\n"
    "    v_tex_pos = a_tex_pos;\n"
    "    v_color = a_color * u_color;\n"
    "}\n"
    "";

ASSET_REGISTER(data_shaders_points_vert, "shaders/points.vert", DATA_data_shaders_points_vert, false)

